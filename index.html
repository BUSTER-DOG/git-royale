<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Flexnite: GitHub Royale</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    canvas { 
      display: block; 
      background: #87ceeb; 
      width: 100vw; 
      height: 100vh; 
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1920" height="1080"></canvas>

  <script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  // MAP SETUP
  const map = {
    width: 3000,
    height: 3000,
    tileSize: 60
  };

  const tileMap = [];
  for (let y = 0; y < map.height / map.tileSize; y++) {
    tileMap[y] = [];
    for (let x = 0; x < map.width / map.tileSize; x++) {
      tileMap[y][x] = {
        type: "grass",
        color: "#228B22"
      };
    }
  }

  // BUILDINGS
  const buildings = [
    { x: 800, y: 700, width: 200, height: 200, color: "#444" },
    { x: 1300, y: 1600, width: 150, height: 150, color: "#555" },
    { x: 2200, y: 400, width: 250, height: 180, color: "#333" },
  ];

  function drawMap(ctx, cameraX, cameraY) {
    const tilesX = Math.ceil(canvas.width / map.tileSize) + 1;
    const tilesY = Math.ceil(canvas.height / map.tileSize) + 1;
    const startX = Math.floor(cameraX / map.tileSize);
    const startY = Math.floor(cameraY / map.tileSize);

    for (let y = 0; y < tilesY; y++) {
      for (let x = 0; x < tilesX; x++) {
        const tile = tileMap[startY + y]?.[startX + x];
        if (!tile) continue;

        ctx.fillStyle = tile.color;
        ctx.fillRect(
          x * map.tileSize - (cameraX % map.tileSize),
          y * map.tileSize - (cameraY % map.tileSize),
          map.tileSize,
          map.tileSize
        );
      }
    }

    for (const b of buildings) {
      ctx.fillStyle = b.color;
      ctx.fillRect(
        b.x - cameraX,
        b.y - cameraY,
        b.width,
        b.height
      );
    }
  }

  // PLAYER
  const player = {
    x: map.width / 2,
    y: map.height / 2,
    size: 40,
    speed: 5,
    color: "purple"
  };

  const keys = {};
  window.addEventListener("keydown", e => keys[e.key] = true);
  window.addEventListener("keyup", e => keys[e.key] = false);

  function isColliding(rect1, rect2) {
    return (
      rect1.x < rect2.x + rect2.width &&
      rect1.x + rect1.size > rect2.x &&
      rect1.y < rect2.y + rect2.height &&
      rect1.y + rect1.size > rect2.y
    );
  }

  function updatePlayer() {
    let newX = player.x;
    let newY = player.y;

    if (keys["w"]) newY -= player.speed;
    if (keys["s"]) newY += player.speed;
    if (keys["a"]) newX -= player.speed;
    if (keys["d"]) newX += player.speed;

    let collision = false;
    for (const b of buildings) {
      if (isColliding({ x: newX, y: newY, size: player.size }, b)) {
        collision = true;
        break;
      }
    }

    if (!collision) {
      player.x = newX;
      player.y = newY;
    }
  }

  function drawPlayer(cameraX, cameraY) {
    ctx.fillStyle = player.color;
    ctx.fillRect(
      player.x - cameraX,
      player.y - cameraY,
      player.size,
      player.size
    );
  }

  // WEAPON SYSTEM
  const bullets = [];
  canvas.addEventListener("mousedown", e => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const angle = Math.atan2(
      mouseY - canvas.height / 2,
      mouseX - canvas.width / 2
    );

    const bullet = {
      x: player.x + player.size / 2,
      y: player.y + player.size / 2,
      dx: Math.cos(angle) * 10,
      dy: Math.sin(angle) * 10,
      size: 8,
      color: "yellow"
    };

    bullets.push(bullet);
  });

  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.dx;
      b.y += b.dy;

      // remove if hits building
      let hit = false;
      for (const building of buildings) {
        if (
          b.x > building.x &&
          b.x < building.x + building.width &&
          b.y > building.y &&
          b.y < building.y + building.height
        ) {
          hit = true;
          break;
        }
      }

      if (
        hit ||
        b.x < 0 ||
        b.x > map.width ||
        b.y < 0 ||
        b.y > map.height
      ) {
        bullets.splice(i, 1);
      }
    }
  }

  function drawBullets(cameraX, cameraY) {
    for (const b of bullets) {
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x - cameraX, b.y - cameraY, b.size, b.size);
    }
  }

  function gameLoop() {
    const cameraX = player.x - canvas.width / 2 + player.size / 2;
    const cameraY = player.y - canvas.height / 2 + player.size / 2;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMap(ctx, cameraX, cameraY);
    updatePlayer();
    updateBullets();
    drawBullets(cameraX, cameraY);
    drawPlayer(cameraX, cameraY);
    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>
</body>
</html>
